package versionsfile

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"path"
	"regexp"
	"strings"

	"github.com/PuerkitoBio/goquery"
)

// RemoteVersionsFile is the representation of the file that gets stored in
// GitHub. That file is pregenerated by parsing go downloads page.
type remoteVersionsFile struct {
	versions map[string][]GoArchive
}

// GetArchivesFor available archives indexed by version for the provided CPU
// architecture and OS.
func (rvf *remoteVersionsFile) getArchivesFor(arch, os string) map[string]GoArchive {
	foundArchives := make(map[string]GoArchive)
	for version, archives := range rvf.versions {
		for _, archive := range archives {
			if archive.ARCH == arch && archive.OS == os {
				foundArchives[version] = archive
				break
			}
		}
	}

	return foundArchives
}

const versionsFileURL = "https://raw.githubusercontent.com/xabierlaiseca/gowrap/master/data/versions.json"

func download() (*remoteVersionsFile, error) {
	response, err := http.Get(versionsFileURL)
	if err != nil {
		return nil, err
	}

	defer response.Body.Close()
	if response.StatusCode != 200 {
		return nil, fmt.Errorf("failed downloading versions file, unexpected status: %d", response.StatusCode)
	}

	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		return nil, err
	}

	versions := make(map[string][]GoArchive)
	err = json.Unmarshal(body, &versions)
	if err != nil {
		return nil, err
	}

	rvf := remoteVersionsFile{
		versions: versions,
	}
	return &rvf, nil
}

func Generate(outputPath string) error {
	downloadsPageDoc, err := getDownloadsPage()
	if err != nil {
		return err
	}

	rvf := extractRemoteVersionsFile(downloadsPageDoc)

	versionsBytes, err := json.Marshal(rvf.versions)
	if err != nil {
		return err
	}

	return ioutil.WriteFile(outputPath, versionsBytes, 0644)
}

const downloadsPageURL = "https://golang.org/dl/"

func getDownloadsPage() (*goquery.Document, error) {
	response, err := http.Get(downloadsPageURL)
	if err != nil {
		return nil, err
	}

	defer response.Body.Close()
	if response.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code (%d) while getting downloads page", response.StatusCode)
	}

	return goquery.NewDocumentFromReader(response.Body)
}

var validGoVersionRegex = regexp.MustCompile(`^go[0-9]+(\.[0-9]+){1,2}$`)

func extractRemoteVersionsFile(doc *goquery.Document) remoteVersionsFile {
	versions := make(map[string][]GoArchive)

	doc.Find(`div[id^="go"]`).
		FilterFunction(func(_ int, selection *goquery.Selection) bool {
			id, _ := selection.Attr("id")
			return validGoVersionRegex.MatchString(id)
		}).
		Each(func(_ int, selection *goquery.Selection) {
			id, _ := selection.Attr("id")
			version := strings.TrimPrefix(id, "go")
			archives := extractArchives(selection.Find("table"))
			versions[version] = archives
		})

	return remoteVersionsFile{versions: versions}
}

var archiveFileRegex = regexp.MustCompile(`^go(?:[0-9]+\.){2,3}([^-]+)-([^\.]+)\..*$`)

func extractArchives(versionSelection *goquery.Selection) []GoArchive {
	var archives []GoArchive

	versionSelection.Find("tbody tr").
		Filter(`:has(td:contains("archive"))`).
		Each(func(_ int, archiveRowSelection *goquery.Selection) {
			archives = append(archives, extractArchive(archiveRowSelection))
		})

	return archives
}

func extractArchive(archiveRowSelection *goquery.Selection) GoArchive {
	link, _ := archiveRowSelection.Find(`td:first-child a`).First().Attr("href")
	filename := path.Base(link)
	matches := archiveFileRegex.FindStringSubmatch(filename)

	checksum := archiveRowSelection.Find(`td:nth-child(6) tt`).Text()
	return GoArchive{
		ARCH:   matches[2],
		OS:     matches[1],
		URL:    link,
		SHA256: checksum,
	}
}
